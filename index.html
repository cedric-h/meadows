<!DOCTYPE html>
<html lang="en">
<head>
  <title>aiden triangle zoom canvas</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <style>
document, body {
  margin: 0px;
  overflow: hidden;
}
  </style>
</head>
<body>
  <canvas id="out"></canvas>
  <script>
"use strict";

const canvas = document.getElementById("out");
const gl = canvas.getContext("webgl2", {
  alpha: false,
  powerPreference: "high-performance"
});
if (!gl) throw new Error("couldn't get gl context");

const program = (() => {
  const vertexShaderSource = `#version 300 es
  precision highp float;

  in vec2 a_position;
  in vec4 a_color;

  out vec4 v_color;

  void main() { gl_Position = vec4(a_position, 0, 1); v_color = a_color; }
  `;

  const fragmentShaderSource = `#version 300 es
  precision highp float;
  in vec4 v_color;
  out vec4 outColor;

  void main() { outColor = v_color + vec4(0.5, 0.5, 0.5, 1); }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) return shader;

    throw new Error(gl.getShaderInfoLog(shader));
  }

  function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) return program;

    throw new Error(gl.getProgramInfoLog(program));
  }

  return createProgram(
    gl,
    createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
    createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)
  );
})();


// look up where the vertex data needs to go.
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const colorAttributeLocation = gl.getAttribLocation(program, "a_color");
const vbuf = gl.createBuffer();

const vertSize = Float32Array.BYTES_PER_ELEMENT * 8;

// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = vbuf)
gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
gl.bufferData(gl.ARRAY_BUFFER, vertSize * 3, gl.DYNAMIC_DRAW);

gl.enableVertexAttribArray(positionAttributeLocation);
gl.enableVertexAttribArray(colorAttributeLocation);

const colorStart = Float32Array.BYTES_PER_ELEMENT * 4;
/* size, type, normalize, stride, offset */
gl.vertexAttribPointer(
  positionAttributeLocation, 2, gl.FLOAT, false, vertSize, 0);
gl.vertexAttribPointer(
  colorAttributeLocation, 4, gl.FLOAT, false, vertSize, colorStart);

gl.useProgram(program);

(async () => {
  const wasmSrc = fetch("build/main.wasm");
  const { instance } =
    await WebAssembly.instantiateStreaming(wasmSrc, { env: {
      print: console.log,
      cosf: Math.cos,
      sinf: Math.sin,
      sqrtf: Math.sqrt,
    } });
  const wasm = instance.exports;

  wasm.init();
  const vbuf = new Float32Array(wasm.memory.buffer, wasm.vbuf(), 8 * 3);

  (window.onresize = () => {
    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(
      0,
      0,
      canvas.width = window.innerWidth,
      canvas.height = window.innerHeight
    );
  })();

  requestAnimationFrame(function frame(time) {
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    wasm.frame(canvas.width, canvas.height, time);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vbuf);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  });

})();
  </script>
</body>
</html>
