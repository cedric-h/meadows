<!DOCTYPE html>
<html lang="en">
<head>
  <title>aiden triangle zoom canvas</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="" />
  <style>
document, body {
  margin: 0px;
  overflow: hidden;
}
  </style>
</head>
<body>
  <canvas id="out"></canvas>
  <script>
"use strict";

const canvas = document.getElementById("out");
const gl = canvas.getContext("webgl2", {
  alpha: false,
  powerPreference: "high-performance"
});
if (!gl) throw new Error("couldn't get gl context");

const program = (() => {
  const vertexShaderSource = `#version 300 es
  in vec4 a_position;
  void main() { gl_Position = a_position; }
  `;

  const fragmentShaderSource = `#version 300 es
  precision highp float;
  out vec4 outColor;

  void main() { outColor = vec4(0.0, 0.2, 0.5, 1); }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) return shader;

    throw new Error(gl.getShaderInfoLog(shader));
  }

  function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) return program;

    throw new Error(gl.getProgramInfoLog(program));
  }

  return createProgram(
    gl,
    createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
    createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)
  );
})();


// look up where the vertex data needs to go.
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const positionBuffer = gl.createBuffer();

// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

gl.bufferData(gl.ARRAY_BUFFER, 3 * 2 * 4, gl.DYNAMIC_DRAW);


const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
gl.enableVertexAttribArray(positionAttributeLocation);

// Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
const size = 2;          // 2 components per iteration
const type = gl.FLOAT;   // the data is 32bit floats
const normalize = false; // don't normalize the data
const stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
const offset = 0;        // start at the beginning of the buffer
gl.vertexAttribPointer(
    positionAttributeLocation, size, type, normalize, stride, offset);

gl.useProgram(program);
gl.bindVertexArray(vao);

(async () => {
  const wasmSrc = fetch("build/main.wasm");
  const { instance } =
    await WebAssembly.instantiateStreaming(wasmSrc, { env: {
      print: console.log,
      cosf: Math.cos,
      sinf: Math.sin,
      sqrtf: Math.sqrt,
    } });
  const wasm = instance.exports;

  wasm.init();
  const vbuf = new Float32Array(wasm.memory.buffer, wasm.vbuf(), 6);

  (window.onresize = () => {
    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(
      0,
      0,
      canvas.width = window.innerWidth,
      canvas.height = window.innerHeight
    );
  })();

  requestAnimationFrame(function frame(time) {
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    wasm.frame(canvas.width, canvas.height, time);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vbuf);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  });

})();
  </script>
</body>
</html>
